# -*- coding: utf-8 -*-
"""Untitled17.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1x26a6cJSvJJIQMcpTDoi89-A3kBkf_pG
"""

import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_squared_error
import joblib

# Sample data generation function
def generate_sample_data(num_samples=1000):
    try:
        np.random.seed(42)
        activity_levels = np.random.randint(1, 10, size=num_samples)  # Activity level from 1 to 10
        food_intake = np.random.randint(50, 150, size=num_samples)  # Food intake in grams
        insulin_doses = (activity_levels * 2) + (food_intake * 0.5) + np.random.normal(0, 5, num_samples)  # Insulin dose calculation
        return pd.DataFrame({'Activity': activity_levels, 'Food': food_intake, 'InsulinDose': insulin_doses})
    except Exception as e:
        print(f"Error generating sample data: {e}")
        return None

# Load and prepare data
def load_data():
    try:
        data = generate_sample_data()
        if data is None:
            raise ValueError("Data generation failed.")
        X = data[['Activity', 'Food']]
        y = data['InsulinDose']
        return train_test_split(X, y, test_size=0.2, random_state=42)
    except Exception as e:
        print(f"Error loading data: {e}")
        return None, None, None, None

# Train the model
def train_model(X_train, y_train):
    try:
        model = RandomForestRegressor(n_estimators=100, random_state=42)
        model.fit(X_train, y_train)
        return model
    except Exception as e:
        print(f"Error training model: {e}")
        return None

# Evaluate the model
def evaluate_model(model, X_test, y_test):
    try:
        predictions = model.predict(X_test)
        mse = mean_squared_error(y_test, predictions)
        print(f"Mean Squared Error: {mse:.2f}")
    except Exception as e:
        print(f"Error evaluating model: {e}")

# Save the model
def save_model(model, filename='insulin_dose_model.pkl'):
    try:
        joblib.dump(model, filename)
        print(f"Model saved to {filename}")
    except Exception as e:
        print(f"Error saving model: {e}")

# Main function to execute the workflow
def main():
    X_train, X_test, y_train, y_test = load_data()
    if X_train is not None and y_train is not None:
        model = train_model(X_train, y_train)
        if model is not None:
            evaluate_model(model, X_test, y_test)
            save_model(model)

if __name__ == "__main__":
    main()

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import plotly.subplots as sp
from scipy.stats import chi2
import statsmodels.api as sm

# import sklearn modules for machine learning
from sklearn.model_selection import train_test_split, GridSearchCV, RandomizedSearchCV, cross_val_score
from sklearn.linear_model import LogisticRegression
from sklearn.tree import DecisionTreeClassifier
from sklearn.ensemble import RandomForestClassifier
from sklearn.svm import SVC
from sklearn.metrics import accuracy_score, confusion_matrix, classification_report
from sklearn.preprocessing import StandardScaler, MinMaxScaler, OneHotEncoder, LabelEncoder

# for saving models
import joblib
import pickle

# set options for better readibility
pd.set_option('display.max_rows', None)
pd.set_option('display.max_columns', None)

# ignore warnings
import warnings
warnings.filterwarnings('ignore')

df = pd.read_csv('/content/sample_data/diabetes.csv')
df.head()

df.tail()

df.shape

df.info()

df.describe()

df.corr()

df.dtypes

df.isnull().sum()

df.quantile([0, 0.05, 0.25, 0.50, 0.75, 0.99, 1]).T

f, ax = plt.subplots(figsize=(10, 8))
fig = sns.boxplot(data=df, orient="h")

numerical_columns = ['Pregnancies', 'Glucose', 'BloodPressure', 'SkinThickness', 'Insulin', 'BMI', 'Age']

import nbformat
print(nbformat.__version__)

for col in numerical_columns:
    fig = px.box(df, y=col, title=f'Boxplot of {col}', points='outliers')
    fig.show()

for col in numerical_columns:
    fig = px.violin(df, y=col, title=f'Violinplot of {col}', points='outliers', box=True)
    fig.show()

from scipy import stats

# Calculating Z-scores for each feature
z_scores = np.abs(stats.zscore(df[numerical_columns]))

# Setting a threshold for outliers, typically Z > 3
outliers = np.where(z_scores > 3)

# Displaying rows with outliers
outlier_rows = df.iloc[outliers[0]]
print("Outliers detected:\n", outlier_rows)

for col in numerical_columns:
    fig = px.histogram(df, x=col, nbins=30, title=f'Histogram of {col}',
    marginal='box', labels={col:col}, color_discrete_sequence=['#636EFA'])
    fig.show()

for col in numerical_columns:
    fig = px.histogram(df, x=col,
    marginal='box', labels={col:col},
    color_discrete_sequence=['#636EFA'],
    histnorm='density')

    # update layout for x and y axis labels
    fig.update_layout(
        xaxis_title=col,
        yaxis_title='Density'
    )

    fig.show()

skewness = df[numerical_columns].skew()
print("Skewness of numerical features:\n,", skewness)

np.log1p(df['Insulin'])

corr = df.corr()
corr

fig = go.Figure(
    data=go.Heatmap(
        z=corr.values,
        x=corr.index,
        y=corr.columns,
        colorscale='Viridis'
    ))

fig.update_layout(title='Correlation Heatmap of Numerical Features',
                  xaxis_nticks=36)
fig.show()

sns.pairplot(df, hue='Outcome', diag_kind='kde', palette='coolwarm')
plt.show()

numerical_columns = ['Pregnancies', 'Glucose', 'BloodPressure', 'SkinThickness', 'Insulin', 'BMI', 'Age']

# Creating a subplot layout for pairwise scatter plots
fig = make_subplots(rows=len(numerical_columns), cols=len(numerical_columns),
                    shared_xaxes=True, shared_yaxes=True,
                    vertical_spacing=0.02, horizontal_spacing=0.02)

# Plot pairwise scatter plots
for i, row_feature in enumerate(numerical_columns):
    for j, col_feature in enumerate(numerical_columns):
        if i == j:  # If same feature, plot a histogram
            fig.add_trace(go.Histogram(x=df[col_feature], nbinsx=20, showlegend=False),
                          row=i+1, col=j+1)
        else:  # Plot scatter plots for different feature combinations
            fig.add_trace(go.Scatter(x=df[col_feature], y=df[row_feature],
                                     mode='markers', marker=dict(color=df['Outcome'], colorscale='Viridis', size=5),
                                     showlegend=False),
                          row=i+1, col=j+1)

# Update layout for better visibility
fig.update_layout(height=1200, width=1200, title_text="Pairwise Scatter Plots with Diagonal Histograms",
                  showlegend=False)

# Show the plot
fig.show()

high_correlation_pairs = corr[corr > 0.7]
print("Highly correlated features:\n", high_correlation_pairs)

mask = np.triu(np.ones_like(corr, dtype=bool))

# Plotting Seaborn heatmap with mask
plt.figure(figsize=(10, 8))
sns.heatmap(corr, mask=mask, annot=True, cmap='coolwarm', fmt=".2f")
plt.title('Correlation Matrix Heatmap')
plt.show()

outcome_counts = df['Outcome'].value_counts()
fig = px.bar(outcome_counts,
            x=outcome_counts.index,
            y=outcome_counts.values,
            color=outcome_counts.index,
            text=outcome_counts.values,
            color_continuous_scale=px.colors.sequential.Viridis,
            labels={'x': 'Diabetes Outcome (0 = No, 1 = Yes)', 'y': 'Count'},
            title='Distribution of Diabetes Outcome')

fig.update_layout(xaxis_title='Outcome (0 = No Diabetes, 1 = Diabetes)',
                  yaxis_title='Number of Patients',
                  showlegend=False)

fig.show()

outcome_percentage = outcome_counts / len(df) * 100
print(f"Percentage of each Outcome class:\n{outcome_percentage}")

fig = px.box(df, x='Outcome', y='Glucose', color='Outcome',
                labels={'Outcome': 'Diabetes Outcome (0 = No, 1 = Yes)', 'Glucose': 'Glucose Level'},
                title='Glucose Levels Against Diabetes Outcome')

fig.show()

fig = px.violin(df, x='Outcome', y='Glucose', color='Outcome',
                labels={'Outcome': 'Diabetes Outcome (0 = No, 1 = Yes)', 'Glucose': 'Glucose Level'},
                title='Glucose Levels Against Diabetes Outcome',
                box=True,)

fig.show()

fig = px.histogram(df, x='Glucose', nbins=30, title='Distribution of Glucose Levels', color='Outcome',
                    marginal='box', labels={'Outcome': 'Diabetes Outcome (0 = No, 1 = Yes)', 'Glucose': 'Glucose Level'},
                    color_discrete_sequence=['#636EFA'], barmode='overlay')

fig.update_layout(barmode='overlay', xaxis_title='Glucose Level', yaxis_title='Count')

fig.show()

fig = px.box(df, x='Outcome', y='Age', color='Outcome',
                labels={'Outcome': 'Diabetes Outcome (0 = No, 1 = Yes)', 'Age': 'Age'},
                title='Age Against Diabetes Outcome',
                color_discrete_sequence=['red', 'blue', 'green'])

fig.show()

fig = px.violin(df, x='Outcome', y='Age',
                            labels={'Outcome': 'Diabetes Outcome (0 = No, 1 = Yes)', 'Age': 'Age (Years)'},
                            title='Violin Plot of Age by Diabetes Outcome',
                            color='Outcome',
                            color_discrete_sequence=['red', 'blue', 'green'])
fig.show()

fig = px.histogram(df, x='Age', color='Outcome',
                             labels={'Outcome': 'Diabetes Outcome (0 = No, 1 = Yes)', 'Age': 'Age (Years)'},
                             title='Histogram of Age by Diabetes Outcome',
                             barmode='overlay')

fig.update_layout(barmode='overlay', xaxis_title='Age (Years)', yaxis_title='Count')
fig.show()

fig = px.box(df, x='Outcome', y='BMI', color='Outcome',
                color_discrete_sequence=['#636EFA', '#EF553B'],
                labels={'Outcome': 'Diabetes Outcome (0 = No, 1 = Yes)', 'BMI': 'Body Mass Index'},
                title='Body Mass Index Against Diabetes Outcome')

fig.show()

fig = px.violin(df, x='Outcome', y='BMI',
                            labels={'Outcome': 'Diabetes Outcome (0 = No, 1 = Yes)', 'BMI': 'Body Mass Index (BMI)'},
                            title='Violin Plot of BMI by Diabetes Outcome',
                            color='Outcome',
                            color_discrete_sequence=['#636EFA', '#EF553B'])  # Custom colors for the classes

fig.show()

fig = px.histogram(df, x='BMI', color='Outcome',
                             labels={'Outcome': 'Diabetes Outcome (0 = No, 1 = Yes)', 'BMI': 'Body Mass Index (BMI)'},
                             title='Histogram of BMI by Diabetes Outcome',
                             barmode='overlay',
                             color_discrete_sequence=['#636EFA', '#EF553B'])  # Custom colors for the classes

fig.update_layout(barmode='overlay', xaxis_title='Body Mass Index (BMI)', yaxis_title='Count')
fig.show()

binned_bmi = pd.cut(df['BMI'], bins=np.arange(10, 60, 5))  # Adjust bins as needed
heatmap_data = df.groupby(['Outcome', binned_bmi]).size().unstack(fill_value=0)

# 2. Heatmap of BMI vs Outcome
fig_heatmap = px.imshow(heatmap_data,
                         labels=dict(x='BMI Range', y='Diabetes Outcome (0 = No, 1 = Yes)', color='Count'),
                         title='Heatmap of BMI Ranges vs Diabetes Outcome',
                         x=heatmap_data.columns.astype(str),  # Convert bins to string for better labeling
                         y=heatmap_data.index,
                         color_continuous_scale=px.colors.sequential.Viridis)

fig_heatmap.show()

fig = px.box(df, x='Outcome', y='Insulin',
                          labels={'Outcome': 'Diabetes Outcome (0 = No, 1 = Yes)', 'Insulin': 'Insulin Levels'},
                          title='Insulin Distribution by Diabetes Outcome',
                          color='Outcome',
                          color_discrete_sequence=['#636EFA', '#EF553B'])  # Custom colors for the classes

fig.show()

fig = px.histogram(df, x='Insulin', color='Outcome',
                                 labels={'Outcome': 'Diabetes Outcome (0 = No, 1 = Yes)', 'Insulin': 'Insulin Levels'},
                                 title='Histogram of Insulin by Diabetes Outcome',
                                 barmode='overlay',
                                 color_discrete_sequence=['#636EFA', '#EF553B'])  # Custom colors for the classes

fig.update_layout(barmode='overlay', xaxis_title='Insulin Levels', yaxis_title='Count')
fig.show()

fig = px.violin(df, x='Outcome', y='Insulin',
                                labels={'Outcome': 'Diabetes Outcome (0 = No, 1 = Yes)', 'Insulin': 'Insulin Levels'},
                                title='Violin Plot of Insulin by Diabetes Outcome',
                                color='Outcome',
                                color_discrete_sequence=['#636EFA', '#EF553B'])  # Custom colors for the classes

fig.show()

features = ['BMI', 'Glucose', 'Insulin', 'Age', 'Outcome']
pairwise_df = df[features]

# Creating a subplot grid for pairwise relationships
fig = sp.make_subplots(rows=len(features)-1, cols=len(features)-1,
                        subplot_titles=[f'{x} vs {y}' for i, x in enumerate(features[:-1]) for y in features[:-1] if x != y],
                        vertical_spacing=0.1)

# Add scatter plots for each pair of features
for i, x in enumerate(features[:-1]):
    for j, y in enumerate(features[:-1]):
        if x != y:
            scatter = px.scatter(pairwise_df, x=x, y=y, color='Outcome',
                                 color_discrete_sequence=['#636EFA', '#EF553B']).data[0]
            fig.add_trace(scatter, row=i+1, col=j+1)

# Update layout
fig.update_layout(title='Pairwise Relationships of Selected Features',
                  height=1000, width=1000,
                  showlegend=False)

fig.show()

X = df.drop(columns='Outcome')
y = df['Outcome']

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

scaler = StandardScaler()
X_train_scaled = scaler.fit_transform(X_train)
X_test_scaled = scaler.transform(X_test)

rfc = RandomForestClassifier(n_estimators=100, random_state=42)
rfc.fit(X_train_scaled, y_train)

feature_importance = rfc.feature_importances_
features = X.columns
importance_df = pd.DataFrame({'Feature': features, 'Importance': feature_importance})
importance_df = importance_df.sort_values(by='Importance', ascending=False)
importance_df

fig_feature_importance = px.bar(importance_df, x='Feature', y='Importance',
                                 labels={'Feature': 'Features', 'Importance': 'Importance Score'},
                                 title='Feature Importance in Predicting Diabetes Outcome',
                                 color='Importance',
                                 color_continuous_scale=px.colors.sequential.Viridis)

# Display the plot
fig_feature_importance.show()

def mahalanobis(X):
    mean = np.mean(X, axis=0)
    cov = np.cov(X, rowvar=False)
    inv_cov_matrix = np.linalg.inv(cov)

    left_term = np.dot((X - mean), inv_cov_matrix)
    mahal = np.dot(left_term, (X - mean).T)
    return np.sqrt(mahal.diagonal())


# calculate Mahalanobis distance for entire dataset
X_features = df.drop(columns='Outcome')
mahalanobis_distances = mahalanobis(X_features)

# set a threshold based on chi-squared distribution for multivariate outliers
threshold = chi2.ppf(0.975, X_features.shape[1])

# identify points that exceed the threshold as outliers
df['Outlier'] = mahalanobis_distances > threshold

# display outliers count
df["Outlier"].value_counts()

fig_scatter_outliers = px.scatter_matrix(df, dimensions=['Glucose', 'Insulin', 'BMI', 'Age'],
                                          color='Outlier',
                                          labels={'Outlier': 'Outlier Status (0 = Inlier, 1 = Outlier)'},
                                          title='Scatter Matrix with Multivariate Outlier Detection',
                                          color_discrete_sequence=['#636EFA', '#EF553B'])

# Update plot layout
fig_scatter_outliers.update_traces(marker=dict(size=4))

# Display the plot
fig_scatter_outliers.show()

fig_glucose_insulin_outliers = px.scatter(df, x='Glucose', y='Insulin', color='Outlier',
                                           labels={'Outlier': 'Outlier Status (0 = Inlier, 1 = Outlier)'},
                                           title='Glucose vs Insulin (Outliers Highlighted)',
                                           color_discrete_sequence=['#636EFA', '#EF553B'])

fig_glucose_insulin_outliers.show()

# BMI vs Age (highlighting outliers)
fig_bmi_age_outliers = px.scatter(df, x='BMI', y='Age', color='Outlier',
                                   labels={'Outlier': 'Outlier Status (0 = Inlier, 1 = Outlier)'},
                                   title='BMI vs Age (Outliers Highlighted)',
                                   color_discrete_sequence=['#636EFA', '#EF553B'])

fig_bmi_age_outliers.show()

df['Outlier'].value_counts()

df = df.drop(columns='Outlier')